<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Test Page</title>
</head>
<body>
    <h1>import os
import sys
import argparse
import numpy as np
import nrrd
from typing import Tuple, Union, Dict
import SimpleITK as sitk

# --- ãƒ‡ãƒ¼ã‚¿ãƒ­ãƒ¼ãƒ‰é–¢æ•° (NPZã®ã¿) ---
def load_npz_data(filepath: str) -> Tuple[np.ndarray, np.ndarray, np.ndarray, int]:
    """
    NPZãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰åº§æ¨™ ('coords') ã¨ãƒ©ãƒ™ãƒ« ('instance_id' ã¾ãŸã¯ 'label') ã‚’èª­ã¿è¾¼ã¿ã€
    ãƒ¦ãƒ‹ãƒ¼ã‚¯ãªãƒ©ãƒ™ãƒ«IDã¨å†ãƒãƒƒãƒ”ãƒ³ã‚°ã•ã‚ŒãŸãƒ©ãƒ™ãƒ«ã‚’è¿”ã™ã€‚
    """
    try:
        with np.load(filepath, allow_pickle=True) as data_npz:
            
            if 'coords' not in data_npz:
                raise ValueError("NPZ file is missing 'coords' key.")
            coords = data_npz['coords'].astype(np.float32)
            
            if 'instance_id' in data_npz:
                labels = data_npz['instance_id'].flatten().astype(np.int32)
            elif 'label' in data_npz:
                labels = data_npz['label'].flatten().astype(np.int32)
            else:
                raise ValueError("NPZ file is missing 'instance_id' or 'label' key.")
                
            if coords.shape[0] != labels.shape[0]:
                raise ValueError("Coordinate and label counts do not match.")

            # ãƒ©ãƒ™ãƒ«ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ— (0ä»¥å¤–ã®ãƒ©ãƒ™ãƒ«ã‚’1ã‹ã‚‰å†ãƒãƒƒãƒ”ãƒ³ã‚°)
            valid_mask = labels >= 0
            coords = coords[valid_mask]
            labels = labels[valid_mask]
            
            # ãƒ©ãƒ™ãƒ«IDã®å†æ¡ç•ªï¼ˆSimpleITKã®LabelMapã¨ã—ã¦ãã‚Œã„ã«æ‰±ã†ãŸã‚ï¼‰
            remapped_labels = np.zeros_like(labels)
            unique_labels_raw = np.unique(labels)
            
            # 0ä»¥å¤–ã®å…ƒã®ãƒ©ãƒ™ãƒ«ã¨ã€æ–°ã—ã„é€£ç¶šã—ãŸãƒ©ãƒ™ãƒ«IDï¼ˆ1, 2, 3...ï¼‰ã®ãƒãƒƒãƒ”ãƒ³ã‚°ã‚’ä¿æŒ
            new_label_map = {}
            new_id = 1
            for old_id in unique_labels_raw:
                if old_id != 0:
                    new_label_map[old_id] = new_id
                    remapped_labels[labels == old_id] = new_id
                    new_id += 1
            
            # æœ€çµ‚çš„ãªãƒ¦ãƒ‹ãƒ¼ã‚¯ãªãƒ©ãƒ™ãƒ«ID (1, 2, 3...) ã‚’æŠ½å‡º
            final_unique_labels = np.unique(remapped_labels)
            final_unique_labels = final_unique_labels[final_unique_labels != 0]

            return coords, remapped_labels, final_unique_labels, coords.shape[0]

    except Exception as e:
        raise ValueError(f"Failed to load NPZ data: {e}")


def get_random_color(label_id: int) -> str:
    """Sliceräº’æ›ã®ãƒ©ãƒ³ãƒ€ãƒ ã‚«ãƒ©ãƒ¼ã‚’ 'R G B' å½¢å¼ã§è¿”ã™"""
    np.random.seed(label_id * 12345)
    r, g, b = np.random.randint(50, 256, 3)
    return f"{r/255.0:.6f} {g/255.0:.6f} {b/255.0:.6f}"


def save_to_nrrd_with_segments(
    segmentation_map: np.ndarray, output_path: str, 
    spacing: np.ndarray, origin: np.ndarray,  # origin ã¯ä¿®æ­£ã•ã‚ŒãŸã‚¼ãƒ­åŸç‚¹
    unique_labels: np.ndarray, label_names: Dict[int, str]
):
    """
    SimpleITKã§NRRDã‚’ä¿å­˜ã—ãŸå¾Œã€Sliceräº’æ›ã®ã‚»ã‚°ãƒ¡ãƒ³ãƒˆæƒ…å ±ã‚’è¿½è¨˜ã™ã‚‹ã€‚
    """
    try:
        import nrrd # nrrdãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã•ã‚Œã¦ã„ã‚‹å‰æ

        # 1. ãƒ‡ãƒ¼ã‚¿ã‚’SimpleITK Imageã«å¤‰æ›ï¼ˆSimpleITKã®è»¸é †åºã‚’ç¶­æŒï¼‰
        image = sitk.GetImageFromArray(segmentation_map.transpose([2, 1, 0]))
        image.SetSpacing(spacing.tolist())
        image.SetOrigin(origin.tolist())  # ä¿®æ­£ã•ã‚ŒãŸã‚¼ãƒ­åŸç‚¹ã‚’ä½¿ç”¨
        image = sitk.Cast(image, sitk.sitkUInt16)
        
        # 2. ã‚«ã‚¹ã‚¿ãƒ ãƒ˜ãƒƒãƒ€ãƒ¼æƒ…å ±ã®æ§‹ç¯‰
        custom_header = {
            'space': 'left-posterior-superior', # Slicerã®ä¸€èˆ¬çš„ãªåº§æ¨™ç³»
        }
        
        # 3. å„ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã®ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ï¼ˆåå‰ã¨è‰²ï¼‰ã‚’è¿½åŠ 
        segment_id_counter = 1
        for label_value in unique_labels:
            if label_value == 0: continue
            
            name = label_names.get(label_value, f"segment_{label_value}")
            color = get_random_color(label_value)
            
            custom_header[f'Segment{segment_id_counter}_ID'] = f'Segment_{label_value}'
            custom_header[f'Segment{segment_id_counter}_Name'] = name
            custom_header[f'Segment{segment_id_counter}_LabelValue'] = str(label_value)
            custom_header[f'Segment{segment_id_counter}_Color'] = color
            custom_header[f'Segment{segment_id_counter}_Type'] = 'Tissue' # ä»®ã®å€¤
            
            segment_id_counter += 1
            
        custom_header['Segmentation_ExportedFrom'] = 'Python'
        
        # 4. nrrdãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½¿ã£ã¦ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜
        data_to_write = sitk.GetArrayFromImage(image).transpose([2, 1, 0])
        nrrd.write(output_path, data_to_write, header=custom_header)
        
        print(f"NRRD file saved to: {output_path} (Slicer LabelMap with Segments).")

    except ImportError:
        print("Error: 'nrrd' library is required for custom segment metadata. Please install it (pip install pynrrd).")
        sitk.WriteImage(image, output_path)
        print(f"NRRD file saved using SimpleITK (No Segment Names).")
    except Exception as e:
        print(f"Error during NRRD writing: {e}")
        # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã¨ã—ã¦SimpleITKã§ä¿å­˜
        sitk.WriteImage(image, output_path)
        print(f"NRRD file saved using SimpleITK (Fallback).")


def apply_sitk_dilation_and_smooth(sitk_image: sitk.Image) -> sitk.Image:
    """SimpleITKã®BinaryDilateã¨Fillholeã€Median Filterã§æ°´å¯†åŒ–ã¨å¹³æ»‘åŒ–ã‚’è¡Œã†"""
    
    fill_filter = sitk.BinaryFillholeImageFilter()
    dilated_image = sitk.Image(sitk_image.GetSize(), sitk.sitkUInt16)
    dilated_image.CopyInformation(sitk_image)

    label_stats = sitk.LabelShapeStatisticsImageFilter()
    label_stats.Execute(sitk_image)
    
    for label in label_stats.GetLabels():
        if label == 0:
            continue
            
        current_mask = sitk.BinaryThreshold(sitk_image, label, label, 1, 0)
        
        # 1. Binary Dilate (æ‹¡å¼µ)
        dilation_filter = sitk.BinaryDilateImageFilter()
        dilation_filter.SetKernelType(sitk.sitkBall)
        dilation_filter.SetKernelRadius(3)
        dilated_mask = dilation_filter.Execute(current_mask)
        
        # 2. Binary Fillhole (ç©´åŸ‹ã‚) ã‚’é©ç”¨
        filled_mask = fill_filter.Execute(dilated_mask) 
        
        dilated_mask_with_label = sitk.Cast(filled_mask, sitk.sitkUInt16) * label
        
        dilated_image = sitk.Maximum(dilated_image, dilated_mask_with_label)
        
    # --- æœ€çµ‚çš„ãªãƒœãƒªãƒ¥ãƒ¼ãƒ å¹³æ»‘åŒ–ã‚¹ãƒ†ãƒƒãƒ— ---
    
    print(" -> INFO: SimpleITK Median Filter é©ç”¨ä¸­...")
    median_filter = sitk.MedianImageFilter()
    sitk_image_smoothed = median_filter.Execute(dilated_image)
    
    print(" -> INFO: SimpleITK Binary Closing é©ç”¨ä¸­ (Radius 2)...")
    closing_filter = sitk.BinaryMorphologicalClosingImageFilter()
    closing_filter.SetKernelType(sitk.sitkBall)
    closing_filter.SetKernelRadius(2) 
    
    binary_all = sitk.BinaryThreshold(sitk_image_smoothed, 1, 65535, 1, 0)
    closed_binary = closing_filter.Execute(binary_all)
    
    closed_np = sitk.GetArrayFromImage(closed_binary)
    smoothed_np = sitk.GetArrayFromImage(sitk_image_smoothed)
    
    final_smoothed_np = np.where(closed_np, smoothed_np, 0)
    
    final_sitk_image = sitk.GetImageFromArray(final_smoothed_np)
    final_sitk_image.CopyInformation(sitk_image)
    
    return final_sitk_image


def main():
    parser = argparse.ArgumentParser(description="NPZãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½¿ç”¨ã—ã€ã‚»ã‚°ãƒ¡ãƒ³ãƒˆåä»˜ãã®NRRDã‚’ç”Ÿæˆã—ã¾ã™ã€‚")
    parser.add_argument('--label_npz_path', type=str, required=True, help='Path to the LABEL NPZ file.')
    parser.add_argument('--output_dir', type=str, required=True, help='Path to the output directory.')
    parser.add_argument('--base_name', type=str, required=True, help='Base name for output files.')
    parser.add_argument('--voxel_size', type=float, default=0.25, help='Voxel size (e.g., 0.25mm).')
    # ğŸ†• ã‚»ã‚°ãƒ¡ãƒ³ãƒˆåãƒãƒƒãƒ”ãƒ³ã‚°ã‚’å¼•æ•°ã¨ã—ã¦è¿½åŠ 
    parser.add_argument('--label_names', type=str, default=None, help='ã‚«ãƒ³ãƒåŒºåˆ‡ã‚Šã®ãƒ©ãƒ™ãƒ«ID:åå‰ã®ãƒšã‚¢ (ä¾‹: "1:pelvis,2:femoral_head")')
    args = parser.parse_args()
    
    # ãƒ©ãƒ™ãƒ«åãƒãƒƒãƒ”ãƒ³ã‚°ã‚’è§£æ
    segment_label_map = {}
    if args.label_names:
        try:
            for item in args.label_names.split(','):
                label_id_str, name = item.split(':')
                segment_label_map[int(label_id_str)] = name
        except ValueError:
            print("è­¦å‘Š: --label_names ã®å½¢å¼ãŒæ­£ã—ãã‚ã‚Šã¾ã›ã‚“ã€‚'ID:åå‰,ID:åå‰' ã®å½¢å¼ã§æŒ‡å®šã—ã¦ãã ã•ã„ã€‚")
            
    # --- 1. ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿ã¨Point Cloudå‡¦ç† ---
    print(f"Loading data from NPZ: {args.label_npz_path}")
    coords, labels, unique_labels, N_points = load_npz_data(args.label_npz_path)
    
    voxel_size = args.voxel_size
    coords_min = np.min(coords, axis=0)
    relative_coords = coords - coords_min[None] # æœ€å°å€¤ã‚’å¼•ã„ã¦ç›¸å¯¾åº§æ¨™ã«å¤‰æ›
    voxel_indices = np.round(relative_coords / voxel_size).astype(np.int32)
    
    # 3. 3Dã‚»ã‚°ãƒ¡ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ãƒãƒƒãƒ—ã®æ§‹ç¯‰
    max_indices = np.max(voxel_indices, axis=0)
    grid_shape = tuple(max_indices + 1)
    
    segmentation_map_CLEANED_np = np.zeros(grid_shape, dtype=np.int32)
    segmentation_map_CLEANED_np[voxel_indices[:, 0], voxel_indices[:, 1], voxel_indices[:, 2]] = labels
    
    # --- 4. SimpleITKã«ã‚ˆã‚‹é«˜é€Ÿãªå‡¦ç† (MERGED_SMOOTH ç›¸å½“ã®ç”Ÿæˆ) ---
    sitk_image_cleaned = sitk.GetImageFromArray(segmentation_map_CLEANED_np.transpose([2, 1, 0]))
    sitk_image_cleaned.SetSpacing(np.array([voxel_size]*3).tolist())
    
    # ğŸ’¡ ä¿®æ­£ç®‡æ‰€ï¼šOriginã‚’ã‚¼ãƒ­ã«è¨­å®šã—ã€åº§æ¨™ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’è§£é™¤
    # ã“ã‚Œã«ã‚ˆã‚Šã€ãƒ¡ãƒƒã‚·ãƒ¥ãŒãƒ“ãƒ¥ãƒ¼ã‚¢ã®åŸç‚¹ä»˜è¿‘ã«ç”Ÿæˆã•ã‚Œã‚‹
    sitk_image_cleaned.SetOrigin([0.0, 0.0, 0.0]) 
    
    sitk_image_cleaned = sitk.Cast(sitk_image_cleaned, sitk.sitkUInt16)

    print(" -> SimpleITKã®é«˜é€Ÿå‡¦ç† (Dilation, Median, Closing) ã‚’é©ç”¨ä¸­...")
    
    sitk_image_merged_smooth = apply_sitk_dilation_and_smooth(sitk_image_cleaned)
    
    # å‡ºåŠ› 2: æ‹¡å¼µã‚ã‚Š (MERGED_SMOOTH ç›¸å½“)
    merged_output_path = os.path.join(args.output_dir, f"{args.base_name}_MERGED_SMOOTH.nrrd")
    
    # æœ€çµ‚çš„ãªã‚«ã‚¹ã‚¿ãƒ ãƒ˜ãƒƒãƒ€ãƒ¼ä»˜ãä¿å­˜ã‚’å®Ÿè¡Œ
    save_to_nrrd_with_segments(
        sitk.GetArrayFromImage(sitk_image_merged_smooth).transpose([2, 1, 0]), 
        merged_output_path, 
        np.array([voxel_size]*3), 
        np.array([0.0, 0.0, 0.0]),  # ğŸ’¡ ä¿®æ­£ç®‡æ‰€ï¼šNRRDãƒ˜ãƒƒãƒ€ãƒ¼ã«ã‚‚ã‚¼ãƒ­åŸç‚¹ã‚’æ›¸ãè¾¼ã‚€
        unique_labels, # NPZã‹ã‚‰æŠ½å‡ºã—ãŸãƒ¦ãƒ‹ãƒ¼ã‚¯ãªãƒ©ãƒ™ãƒ«IDã‚’æ¸¡ã™
        segment_label_map # ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³ã‹ã‚‰èª­ã¿è¾¼ã‚“ã ã‚»ã‚°ãƒ¡ãƒ³ãƒˆåã‚’æ¸¡ã™
    )
    
    print("Script finished. (Generated CLEANED and MERGED_SMOOTH NRRD files)")

if __name__ == '__main__':
    main()</h1>
</body>
</html>