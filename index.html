<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Test Page</title>
</head>
<body>
    <h1>import numpy as np
import SimpleITK as sitk
from skimage import measure
import trimesh
import os
import argparse
from typing import Tuple, List, Union

# --- ç‰©ç†ã‚¹ã‚±ãƒ¼ãƒ«ã¨è§£åƒåº¦è¨­å®š ---
VOXEL_SIZE = 1.0
SCALE_FACTOR = 1.0 / VOXEL_SIZE

# --- è¨­å®šã¨ãƒ‘ã‚¹ ---
BASE_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), '..', '..')
OUTPUT_MESH_RELATIVE_PATH = "processed_meshes"
OUTPUT_FULL_PATH = os.path.join(BASE_DIR, OUTPUT_MESH_RELATIVE_PATH)


# --- ãƒ©ãƒ³ãƒ€ãƒ ãªè‰²ç”Ÿæˆãƒ˜ãƒ«ãƒ‘ãƒ¼ ---
def get_random_color(label_id: int) -> np.ndarray:
    np.random.seed(label_id * 12345)
    return np.random.randint(50, 256, 3, dtype=np.uint8)


# -----------------------------------------------
# NRRDãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ (å˜ä½“)
# -----------------------------------------------
def load_single_nrrd(nrrd_path: str) -> Union[sitk.Image, None]:
    try:
        sitk_image = sitk.ReadImage(nrrd_path)
        print(f" -> NRRDãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ: {os.path.basename(nrrd_path)}")
        print(f" -> ãƒœãƒªãƒ¥ãƒ¼ãƒ å½¢çŠ¶: {sitk_image.GetSize()}")
        return sitk_image
    except Exception as e:
        print(f"Error: NRRDãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ ({os.path.basename(nrrd_path)}): {e}")
        return None


# STEP 1: ãƒ©ãƒ™ãƒ«IDã«åŸºã¥ã„ã¦ãƒã‚¤ãƒŠãƒªãƒã‚¹ã‚¯ã‚’æŠ½å‡º
def create_label_mask(sitk_image, label_id):
    binary_filter = sitk.BinaryThresholdImageFilter()
    binary_filter.SetLowerThreshold(label_id)
    binary_filter.SetUpperThreshold(label_id)
    binary_filter.SetInsideValue(1)
    binary_filter.SetOutsideValue(0)
    label_mask = binary_filter.Execute(sitk_image)
    return sitk.Cast(label_mask, sitk.sitkUInt8)


# STEP 2: éª¨é ­ã®ä¸­ç©ºã‹ã‚‰ä¸­å®Ÿã«ï¼ˆç©´åŸ‹ã‚å‡¦ç†ï¼‰
def fill_holes(sitk_binary_image):
    fill_filter = sitk.BinaryFillholeImageFilter()
    filled_image = fill_filter.Execute(sitk_binary_image)
    return sitk.Cast(filled_image, sitk.sitkUInt8)


# STEP 3: ãƒœãƒªãƒ¥ãƒ¼ãƒ å¹³æ»‘åŒ– (ç„¡åŠ¹åŒ–)
# âš ï¸ é«˜è§£åƒåº¦ãƒ‡ãƒ¼ã‚¿ã§ä½“ç©æ¶ˆå¤±ã®åŸå› ã¨ãªã‚‹ãŸã‚ã€ã“ã®é–¢æ•°ã¯å®Ÿè¡Œã—ã¾ã›ã‚“ã€‚
def apply_volume_smoothing(sitk_binary_image, radius=4):    
    print(f" -> INFO: BinaryMorphologicalOpening ã¨ Closing ã§ãƒœãƒªãƒ¥ãƒ¼ãƒ å¹³æ»‘åŒ–ã‚’é©ç”¨ã—ã¾ã™ (Radius: {radius} voxels)ã€‚")
    # ... (å…ƒã®ãƒ­ã‚¸ãƒƒã‚¯ã¯ä¿æŒã™ã‚‹ãŒã€run_processing_pipelineã§ã‚¹ã‚­ãƒƒãƒ—)
    return sitk.Cast(sitk_binary_image, sitk.sitkUInt8)


# STEP 4: ãƒ¡ãƒƒã‚·ãƒ¥ç”Ÿæˆã¨ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜
def generate_single_colored_mesh(sitk_image, label_id, is_right_side_fracture):
    mask_array = sitk.GetArrayFromImage(sitk_image)
        
    if not np.any(mask_array): return None, "Volume empty"

    # 1. ãƒãƒ¼ãƒãƒ³ã‚°ã‚­ãƒ¥ãƒ¼ãƒ–ã‚’å®Ÿè¡Œ (ç”Ÿãƒ¡ãƒƒã‚·ãƒ¥ - ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ç©ºé–“)
    spacing = sitk_image.GetSpacing()
    vertices_idx, faces, _, _ = measure.marching_cubes(mask_array, level=0.5, spacing=spacing)    

    if vertices_idx.size == 0: return None, "Mesh is empty after initial MC"
        
    # åº§æ¨™ä¿®æ­£ï¼šæ‰‹å‹•è¨ˆç®—ã§Yè»¸ã¨Zè»¸ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’å…¥ã‚Œæ›¿ãˆã‚‹ (ã­ã˜ã‚Œè§£æ¶ˆã®ä¿®æ­£)
    origin = np.array(sitk_image.GetOrigin())    
        
    mesh_vertices_phys = np.zeros_like(vertices_idx)

    # Xåº§æ¨™ (k) ã¯ãã®ã¾ã¾
    mesh_vertices_phys[:, 0] = vertices_idx[:, 2] * spacing[0] + origin[0]    
        
    # Yåº§æ¨™ â† Zè»¸ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ i ã‚’ä½¿ç”¨ (è»¸å…¥ã‚Œæ›¿ãˆ)
    mesh_vertices_phys[:, 1] = vertices_idx[:, 0] * spacing[1] + origin[1]    
        
    # Zåº§æ¨™ â† Yè»¸ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ j ã‚’ä½¿ç”¨ (è»¸å…¥ã‚Œæ›¿ãˆ)
    mesh_vertices_phys[:, 2] = vertices_idx[:, 1] * spacing[2] + origin[2]    
        
    # æ–°ã—ã„ç‰©ç†åº§æ¨™ã§ãƒ¡ãƒƒã‚·ãƒ¥ã‚’ç”Ÿæˆ
    mesh = trimesh.Trimesh(vertices=mesh_vertices_phys, faces=faces)
        
    # ç©ºãƒ¡ãƒƒã‚·ãƒ¥ãƒã‚§ãƒƒã‚¯
    if mesh.is_empty or len(mesh.faces) == 0:    
        return None, "Mesh is empty after coordinate transformation"
        
    if mesh.volume < 0:
        mesh.faces = mesh.faces[:, ::-1]
            
    if is_right_side_fracture:
        mirror_matrix = np.array([[-1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]])
        mesh.apply_transform(mirror_matrix)

    color = get_random_color(label_id)
    mesh.visual.vertex_colors = np.tile(color, (len(mesh.vertices), 1))
        
    return mesh, "Success"


# --- ãƒ¡ã‚¤ãƒ³å®Ÿè¡Œé–¢æ•° ---
def run_processing_pipeline(nrrd_paths: List[str], is_right_side_fracture=False):
    if len(nrrd_paths) != 1:
        print("Error: å‡¦ç†ã™ã‚‹NRRDãƒ•ã‚¡ã‚¤ãƒ«ã¯MERGEDãƒ•ã‚¡ã‚¤ãƒ«1ã¤ã®ã¿ã‚’æŒ‡å®šã—ã¦ãã ã•ã„ã€‚")
        return

    # 1. NRRDãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ (MERGEDã®ã¿)
    sitk_image_full = load_single_nrrd(nrrd_paths[0])
    if sitk_image_full is None: return

    # 2. ãƒ©ãƒ™ãƒ«ã®ç‰¹å®š
    label_stats = sitk.LabelShapeStatisticsImageFilter()
    label_stats.Execute(sitk_image_full)
        
    foreground_labels = [label for label in label_stats.GetLabels() if label != 0]

    print(f"Step 0: {len(foreground_labels)}å€‹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹IDã«å¯¾ã—ã¦å‡¦ç†ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚")
        
    # 3. å„ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹IDã«å¯¾ã™ã‚‹å‡¦ç†ã®åå¾©
    meshes_with_volumes = []
    for label_id in foreground_labels:
        print(f"\n--- Processing Label ID: {label_id} ---")
            
        processed_image = create_label_mask(sitk_image_full, label_id)
        filled_image = fill_holes(processed_image)
            
        # âš ï¸ ä½“ç©æ¶ˆå¤±ã‚¨ãƒ©ãƒ¼å›é¿ã®ãŸã‚ã€apply_volume_smoothingã¯ã‚¹ã‚­ãƒƒãƒ—ã—ã€filled_imageã‚’ç›´æ¥ä½¿ç”¨
        smoothed_volume = filled_image
            
        mesh, status = generate_single_colored_mesh(
            smoothed_volume,    
            label_id,
            is_right_side_fracture
        )
            
        if status == "Success" and mesh is not None:
            # --- ç°¡ç•¥åŒ– (Trimesh APIä¿®æ­£ã¨å¼·åŒ–) ---
            target_reduction_1 = 0.50 # 50%ã«å‰Šæ¸›
            print(f" -> INFO: [1/2] å®‰å®šåŒ–ã®ãŸã‚{target_reduction_1*100:.0f}%ã«å‰Šæ¸›ã—ã¾ã™ã€‚")
            try:
                initial_faces = len(mesh.faces)
                target_faces = int(initial_faces * (1.0 - target_reduction_1))
                
                # ğŸ’¡ ä¿®æ­£: APIã‚’ target_reduction ã‹ã‚‰ target_faces ã«å¤‰æ›´ã—ã€Trimesh v4.x APIã«å¯¾å¿œ
                mesh = trimesh.Trimesh.simplify_quadric_decimation(
                    mesh,  # ãƒ¡ãƒƒã‚·ãƒ¥ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å¼•æ•°ã¨ã—ã¦æ¸¡ã™
                    target_faces=target_faces
                )
                print(f" -> INFO: ç¬¬1æ®µéšç°¡ç•¥åŒ–å®Œäº†ã€‚ãƒãƒªã‚´ãƒ³æ•°: {len(mesh.faces)}")
            except Exception as e:
                # APIã‚¨ãƒ©ãƒ¼ã®å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—ï¼ˆä¾å­˜é–¢ä¿‚ã®å•é¡Œã‚‚å«ã‚€ï¼‰
                print(f" -> WARNING: ç°¡ç•¥åŒ–ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ (API/ä¾å­˜æ€§): {e}. ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã™ã€‚")
                
            # --- å¼·åŠ›ãªTaubinå¹³æ»‘åŒ– ---
            NEW_ITERATIONS = 40 # ä»¥å‰ã®15å›ã‹ã‚‰å¼·åŒ–
            try:
                print(f" -> INFO: å¼·åŠ›ãªTaubinå¹³æ»‘åŒ–ã‚’é©ç”¨ã—ã¾ã™ ({NEW_ITERATIONS}å›)ã€‚")
                mesh = trimesh.smoothing.filter_taubin(mesh, lamb=0.5, nu=-0.505, iterations=NEW_ITERATIONS)
                print(" -> INFO: æœ€çµ‚å¹³æ»‘åŒ–å‡¦ç†å®Œäº†ã€‚")
            except Exception as e:
                print(f" -> WARNING: æœ€çµ‚å¹³æ»‘åŒ–å‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {e}. ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã™ã€‚")
                
            meshes_with_volumes.append((mesh, mesh.volume))
        else:
            print(f" -> WARNING: Label ID {label_id} ã®ãƒ¡ãƒƒã‚·ãƒ¥ç”Ÿæˆã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã™ã€‚ç†ç”±: {status}")

    # --- 4. ãƒ¡ãƒƒã‚·ãƒ¥ã®çµåˆã¨å¾Œå‡¦ç† ---
    if not meshes_with_volumes:
        print("\n--- ERROR: æœ‰åŠ¹ãªãƒ¡ãƒƒã‚·ãƒ¥ãŒä¸€ã¤ã‚‚ç”Ÿæˆã•ã‚Œã¾ã›ã‚“ã§ã—ãŸã€‚çµ‚äº†ã—ã¾ã™ã€‚ ---")
        return

    # 4.1. ãƒã‚¤ã‚ºé™¤å»
    volumes = [mesh.volume for mesh, vol in meshes_with_volumes]
    median_volume = np.median(volumes)
    NOISE_THRESHOLD_FACTOR = 0.01
    threshold_volume = median_volume * NOISE_THRESHOLD_FACTOR
        
    final_meshes = [mesh for mesh, vol in meshes_with_volumes if vol > threshold_volume]

    if not final_meshes:
        print("\n--- ERROR: ãƒã‚¤ã‚ºé™¤å»å¾Œã€æœ‰åŠ¹ãªãƒ¡ãƒƒã‚·ãƒ¥ãŒæ®‹ã£ã¦ã„ã¾ã›ã‚“ã€‚çµ‚äº†ã—ã¾ã™ã€‚ ---")
        return

    # âœ… ãƒ¡ãƒƒã‚·ãƒ¥ã‚’çµåˆ (trimesh.util.concatenate)
    final_mesh = trimesh.util.concatenate(final_meshes)
        
    # çµåˆã•ã‚ŒãŸæœ€çµ‚ãƒ¡ãƒƒã‚·ãƒ¥å…¨ä½“ã‚’åŸç‚¹ä¸­å¿ƒã«å†é…ç½® 
    final_mesh_center = final_mesh.bounding_box.centroid
    final_mesh.apply_translation(-final_mesh_center)
    print(f" -> INFO: çµåˆã•ã‚ŒãŸå…¨ãƒ¡ãƒƒã‚·ãƒ¥ã‚’åŸç‚¹ä¸­å¿ƒã«ç§»å‹•ã—ã¾ã—ãŸã€‚")

    if not os.path.exists(OUTPUT_FULL_PATH): os.makedirs(OUTPUT_FULL_PATH)
        
    # å‡ºåŠ›ãƒ‘ã‚¹è¨­å®š
    base_file_name = os.path.splitext(os.path.basename(nrrd_paths[0]))[0]
    # å‡ºåŠ›ãƒ•ã‚¡ã‚¤ãƒ«åã¯çµåˆã•ã‚ŒãŸå˜ä¸€ãƒ•ã‚¡ã‚¤ãƒ«ã¨ãªã‚‹
    output_path = os.path.join(OUTPUT_FULL_PATH, f"{base_file_name}_FINAL_COMBINED_SURFACE.ply")
        
    final_mesh.export(output_path, file_type='ply')
        
    print(f"\n--- Pipeline Finished ---")
    print(f"âœ… æœ€çµ‚çš„ãªçµåˆã•ã‚ŒãŸå®‰å®šãƒ¡ãƒƒã‚·ãƒ¥ãŒ {output_path} ã«ä¿å­˜ã•ã‚Œã¾ã—ãŸã€‚")


# -----------------------------------------------
# ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³å¼•æ•°å‡¦ç†ãƒ–ãƒ­ãƒƒã‚¯ (å¤‰æ›´ãªã—)
# -----------------------------------------------
if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="å˜ä¸€ã®NRRDãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ãƒ¡ãƒƒã‚·ãƒ¥ã‚’ç”Ÿæˆã™ã‚‹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã€‚")
    parser.add_argument('nrrd_path', type=str, help='å…¥åŠ›NRRDãƒ•ã‚¡ã‚¤ãƒ«ã¸ã®ãƒ‘ã‚¹ (MERGEDãƒ•ã‚¡ã‚¤ãƒ«ã®ã¿ã‚’æŒ‡å®š)ã€‚')
    parser.add_argument('--right', action='store_true', help='ãƒ¡ãƒƒã‚·ãƒ¥ã‚’å·¦å³åè»¢ã™ã‚‹å ´åˆã«æŒ‡å®šã—ã¾ã™ã€‚')
    args = parser.parse_args()
        
    nrrd_paths = [args.nrrd_path] if args.nrrd_path else []

    valid_paths = [p for p in nrrd_paths if os.path.exists(p)]
        
    if len(valid_paths) != len(nrrd_paths):
        missing_paths = [p for p in nrrd_paths if not os.path.exists(p)]
        print(f"ã‚¨ãƒ©ãƒ¼: NRRDãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: {missing_paths}")
    elif not valid_paths:
        print("ã‚¨ãƒ©ãƒ¼: å‡¦ç†ã™ã‚‹NRRDãƒ•ã‚¡ã‚¤ãƒ«ãŒæŒ‡å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚")
    else:
        run_processing_pipeline(
            valid_paths,
            is_right_side_fracture=args.right
        )</h1>
</body>
</html>